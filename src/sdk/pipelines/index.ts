import {
    CallApi,
    CollectionEntity,
    CreateCollectionParamsDto,
    CreateStackParamsDto,
    GetCollectionParamsDto,
    ListStacksParamsDto,
    PipelineEntity,
    PipelinesApi,
    StackEntity,
} from '../../autogenerated';
import { SDKOptions } from '../../types';
import { Pipeline } from '@hautechai/pipelines';
import { useAutogeneratedAPI } from '../api';

const pipelines = (options: SDKOptions) => {
    const api = useAutogeneratedAPI({ API: PipelinesApi, options });
    const callAPI = useAutogeneratedAPI({ API: CallApi, options });

    const createPipeline = () =>
        new Pipeline({
            collections: {
                create: (params: CreateCollectionParamsDto): Promise<CollectionEntity> =>
                    callAPI.call({
                        run: (methods) => methods.callControllerCallCollectionsCreateV1(params),
                    }),
                get: (params: GetCollectionParamsDto): Promise<CollectionEntity> =>
                    callAPI.call({
                        run: (methods) => methods.callControllerCallCollectionsGetV1(params),
                    }),
            },
            stacks: {
                create: (params: CreateStackParamsDto): Promise<StackEntity> =>
                    callAPI.call({
                        run: (methods) => methods.callControllerCallStacksCreateV1(params),
                    }),
                get: (params: ListStacksParamsDto): Promise<StackEntity> =>
                    callAPI.call({
                        run: (methods) => methods.callControllerCallStacksListV1(params),
                    }),
            },
        });

    return {
        create: async (props: {
            metadata?: any;
            tasks: (pipeline: ReturnType<typeof createPipeline>) => ReturnType<typeof createPipeline>;
        }): Promise<PipelineEntity> =>
            api.call({
                run: (methods) =>
                    methods.pipelinesControllerCreatePipelineV1({
                        metadata: props.metadata,
                        tasks: props.tasks(createPipeline()).tasks,
                    }),
            }),
        get: async (props: { id: string }): Promise<PipelineEntity | undefined> =>
            api.callWithReturningUndefinedOn404({
                run: (methods) => methods.pipelinesControllerGetPipelineV1(props.id),
            }),
        wait: async (props: { id: string; timeoutInSeconds?: number }): Promise<PipelineEntity> =>
            new Promise((resolve, reject) => {
                const initialDelay = 5000;
                const delay = 2000;

                let timeoutId: NodeJS.Timeout;
                const poll = async () => {
                    const pipeline = (await api.call({
                        run: (methods) => methods.pipelinesControllerGetPipelineV1(props.id),
                    })) as PipelineEntity;
                    if (pipeline.status === 'completed') return resolve(pipeline);
                    if (pipeline.status === 'failed') return reject(pipeline);
                    timeoutId = setTimeout(poll, delay);
                };
                timeoutId = setTimeout(poll, initialDelay);
            }),
    };
};

export default pipelines;
