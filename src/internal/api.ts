/* tslint:disable */
/* eslint-disable */
/**
 * Hautech API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountEntity
 */
export interface AccountEntity {
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'type': AccountEntityTypeEnum;
}

export const AccountEntityTypeEnum = {
    Root: 'root',
    User: 'user'
} as const;

export type AccountEntityTypeEnum = typeof AccountEntityTypeEnum[keyof typeof AccountEntityTypeEnum];

/**
 * 
 * @export
 * @interface AddAccessParamsDto
 */
export interface AddAccessParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddAccessParamsDto
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAccessParamsDto
     */
    'groupId'?: string;
    /**
     * 
     * @type {object}
     * @memberof AddAccessParamsDto
     */
    'resource': object;
    /**
     * 
     * @type {string}
     * @memberof AddAccessParamsDto
     */
    'resourceId': string;
    /**
     * 
     * @type {object}
     * @memberof AddAccessParamsDto
     */
    'role': object;
}
/**
 * 
 * @export
 * @interface AddAccountToGroupControllerParamsDto
 */
export interface AddAccountToGroupControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupControllerParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupControllerParamsDto
     */
    'role': AddAccountToGroupControllerParamsDtoRoleEnum;
}

export const AddAccountToGroupControllerParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type AddAccountToGroupControllerParamsDtoRoleEnum = typeof AddAccountToGroupControllerParamsDtoRoleEnum[keyof typeof AddAccountToGroupControllerParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface AddBalanceControllerParamsDto
 */
export interface AddBalanceControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddBalanceControllerParamsDto
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface AddItemsToCollectionControllerParamsDto
 */
export interface AddItemsToCollectionControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToCollectionControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddOperationsToStackControllerParamsDto
 */
export interface AddOperationsToStackControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddOperationsToStackControllerParamsDto
     */
    'operationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface BalanceResultDto
 */
export interface BalanceResultDto {
    /**
     * 
     * @type {string}
     * @memberof BalanceResultDto
     */
    'balance': string;
}
/**
 * 
 * @export
 * @interface CollectionEntity
 */
export interface CollectionEntity {
    /**
     * 
     * @type {number}
     * @memberof CollectionEntity
     */
    'kind': number;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof CollectionEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CreateAccountParamsDto
 */
export interface CreateAccountParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountParamsDto
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionParamsDto
 */
export interface CreateCollectionParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateCollectionParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CreateImageParamsDto
 */
export interface CreateImageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateImageParamsDto
     */
    'fileToken'?: string;
}
/**
 * 
 * @export
 * @interface CreatePipelineParamsDto
 */
export interface CreatePipelineParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'metadata'?: object;
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'tasks': object;
}
/**
 * 
 * @export
 * @interface CreatePoseParamsDto
 */
export interface CreatePoseParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreatePoseParamsDto
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreatePoseParamsDto
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface CreateStackParamsDto
 */
export interface CreateStackParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateStackParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CreateStorageRecordParamsDto
 */
export interface CreateStorageRecordParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateStorageRecordParamsDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof CreateStorageRecordParamsDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface DeleteStorageParamsDto
 */
export interface DeleteStorageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteStorageParamsDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface GetOperationsParamsDto
 */
export interface GetOperationsParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetOperationsParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GetStorageRecordParamsDto
 */
export interface GetStorageRecordParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetStorageRecordParamsDto
     */
    'keys': Array<string>;
}
/**
 * 
 * @export
 * @interface GetUrlsForImagesParamsDto
 */
export interface GetUrlsForImagesParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUrlsForImagesParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupEntity
 */
export interface GroupEntity {
    /**
     * 
     * @type {string}
     * @memberof GroupEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupEntity
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ImageEntity
 */
export interface ImageEntity {
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'kind': ImageEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ImageEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof ImageEntity
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ImageEntity
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'format': string;
}

export const ImageEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type ImageEntityKindEnum = typeof ImageEntityKindEnum[keyof typeof ImageEntityKindEnum];

/**
 * 
 * @export
 * @interface ImageUrlsResultDto
 */
export interface ImageUrlsResultDto {
    /**
     * 
     * @type {string}
     * @memberof ImageUrlsResultDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrlsResultDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface InitializeImageUploadResultDto
 */
export interface InitializeImageUploadResultDto {
    /**
     * 
     * @type {string}
     * @memberof InitializeImageUploadResultDto
     */
    'uploadUrl': string;
}
/**
 * 
 * @export
 * @interface Input
 */
export interface Input {
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'age'?: InputAgeEnum;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'angle'?: InputAngleEnum;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'background'?: InputBackgroundEnum;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'ethnicity'?: InputEthnicityEnum;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'gender'?: InputGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'photoType'?: InputPhotoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'productDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'prompt'?: string;
}

export const InputAgeEnum = {
    Adult: 'adult',
    Infant: 'infant',
    PreTeen: 'pre-teen',
    Senior: 'senior',
    Teen: 'teen',
    Toddler: 'toddler'
} as const;

export type InputAgeEnum = typeof InputAgeEnum[keyof typeof InputAgeEnum];
export const InputAngleEnum = {
    Back: 'back',
    Front: 'front',
    Side: 'side'
} as const;

export type InputAngleEnum = typeof InputAngleEnum[keyof typeof InputAngleEnum];
export const InputBackgroundEnum = {
    Beach: 'beach',
    City: 'city',
    Desert: 'desert',
    Hotel: 'hotel',
    Lounge: 'lounge',
    Paris: 'paris',
    Park: 'park',
    Street: 'street',
    Studio: 'studio'
} as const;

export type InputBackgroundEnum = typeof InputBackgroundEnum[keyof typeof InputBackgroundEnum];
export const InputEthnicityEnum = {
    African: 'african',
    AfricanAmerican: 'african-american',
    Asian: 'asian',
    Australian: 'australian',
    CentralAsian: 'central-asian',
    European: 'european',
    Indian: 'indian',
    MiddleEastern: 'middle-eastern',
    NativeAmerican: 'native-american'
} as const;

export type InputEthnicityEnum = typeof InputEthnicityEnum[keyof typeof InputEthnicityEnum];
export const InputGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type InputGenderEnum = typeof InputGenderEnum[keyof typeof InputGenderEnum];
export const InputPhotoTypeEnum = {
    Closeup: 'closeup',
    Fullbody: 'fullbody',
    Headshot: 'headshot'
} as const;

export type InputPhotoTypeEnum = typeof InputPhotoTypeEnum[keyof typeof InputPhotoTypeEnum];

/**
 * 
 * @export
 * @interface ListCollectionItemsDto
 */
export interface ListCollectionItemsDto {
    /**
     * 
     * @type {Array<ResourceEntity>}
     * @memberof ListCollectionItemsDto
     */
    'data': Array<ResourceEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListCollectionItemsDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListCollectionsDto
 */
export interface ListCollectionsDto {
    /**
     * 
     * @type {Array<CollectionEntity>}
     * @memberof ListCollectionsDto
     */
    'data': Array<CollectionEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListCollectionsDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListCollectionsDtoPageInfo
 */
export interface ListCollectionsDtoPageInfo {
    /**
     * 
     * @type {string}
     * @memberof ListCollectionsDtoPageInfo
     */
    'nextCursor': string;
}
/**
 * 
 * @export
 * @interface ListOperationsDto
 */
export interface ListOperationsDto {
    /**
     * 
     * @type {Array<OperationEntity>}
     * @memberof ListOperationsDto
     */
    'data': Array<OperationEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListOperationsDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListStacksDto
 */
export interface ListStacksDto {
    /**
     * 
     * @type {Array<StackEntity>}
     * @memberof ListStacksDto
     */
    'data': Array<StackEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListStacksDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface OperationEntity
 */
export interface OperationEntity {
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'kind': OperationEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'input': object;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'output': object | null;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'status': OperationEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'type': string;
}

export const OperationEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type OperationEntityKindEnum = typeof OperationEntityKindEnum[keyof typeof OperationEntityKindEnum];
export const OperationEntityStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type OperationEntityStatusEnum = typeof OperationEntityStatusEnum[keyof typeof OperationEntityStatusEnum];

/**
 * 
 * @export
 * @interface PipelineEntity
 */
export interface PipelineEntity {
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'kind': PipelineEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'permissions': object;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'state': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'status': PipelineEntityStatusEnum;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'tasks': object;
}

export const PipelineEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type PipelineEntityKindEnum = typeof PipelineEntityKindEnum[keyof typeof PipelineEntityKindEnum];
export const PipelineEntityStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Success: 'success',
    Failed: 'failed'
} as const;

export type PipelineEntityStatusEnum = typeof PipelineEntityStatusEnum[keyof typeof PipelineEntityStatusEnum];

/**
 * 
 * @export
 * @interface RemoveAccessParamsDto
 */
export interface RemoveAccessParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveAccessParamsDto
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccessParamsDto
     */
    'groupId'?: string;
    /**
     * 
     * @type {object}
     * @memberof RemoveAccessParamsDto
     */
    'resource': object;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccessParamsDto
     */
    'resourceId': string;
    /**
     * 
     * @type {object}
     * @memberof RemoveAccessParamsDto
     */
    'role': object;
}
/**
 * 
 * @export
 * @interface RemoveAccountFromGroupControllerParamsDto
 */
export interface RemoveAccountFromGroupControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupControllerParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupControllerParamsDto
     */
    'role': RemoveAccountFromGroupControllerParamsDtoRoleEnum;
}

export const RemoveAccountFromGroupControllerParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type RemoveAccountFromGroupControllerParamsDtoRoleEnum = typeof RemoveAccountFromGroupControllerParamsDtoRoleEnum[keyof typeof RemoveAccountFromGroupControllerParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface RemoveItemsFromCollectionControllerParamsDto
 */
export interface RemoveItemsFromCollectionControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveItemsFromCollectionControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface RemoveOperationsFromStackControllerParamsDto
 */
export interface RemoveOperationsFromStackControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveOperationsFromStackControllerParamsDto
     */
    'operationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ResourceEntity
 */
export interface ResourceEntity {
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'kind': ResourceEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ResourceEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'updatedAt': string;
}

export const ResourceEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type ResourceEntityKindEnum = typeof ResourceEntityKindEnum[keyof typeof ResourceEntityKindEnum];

/**
 * 
 * @export
 * @interface StackEntity
 */
export interface StackEntity {
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'kind': StackEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StackEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<OperationEntity>}
     * @memberof StackEntity
     */
    'operations': Array<OperationEntity>;
}

export const StackEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type StackEntityKindEnum = typeof StackEntityKindEnum[keyof typeof StackEntityKindEnum];

/**
 * 
 * @export
 * @interface StorageEntity
 */
export interface StorageEntity {
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'kind': StorageEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StorageEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof StorageEntity
     */
    'value': object;
}

export const StorageEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type StorageEntityKindEnum = typeof StorageEntityKindEnum[keyof typeof StorageEntityKindEnum];

/**
 * 
 * @export
 * @interface StorageRecordsResultDto
 */
export interface StorageRecordsResultDto {
    /**
     * 
     * @type {string}
     * @memberof StorageRecordsResultDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof StorageRecordsResultDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface UpdateMetadataDto
 */
export interface UpdateMetadataDto {
    /**
     * 
     * @type {object}
     * @memberof UpdateMetadataDto
     */
    'overwrite': object;
}
/**
 * 
 * @export
 * @interface UpdateStorageRecordParamsDto
 */
export interface UpdateStorageRecordParamsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateStorageRecordParamsDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof UpdateStorageRecordParamsDto
     */
    'value': object;
}

/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddAccessParamsDto} addAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerAddAccessV1: async (addAccessParamsDto: AddAccessParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addAccessParamsDto' is not null or undefined
            assertParamExists('accessControllerAddAccessV1', 'addAccessParamsDto', addAccessParamsDto)
            const localVarPath = `/v1/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccessParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} resource 
         * @param {string} resourceId 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerCheckAccessV1: async (resource: string, resourceId: string, action: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('accessControllerCheckAccessV1', 'resource', resource)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('accessControllerCheckAccessV1', 'resourceId', resourceId)
            // verify required parameter 'action' is not null or undefined
            assertParamExists('accessControllerCheckAccessV1', 'action', action)
            const localVarPath = `/v1/access/check/{resource}/{resourceId}/{action}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveAccessParamsDto} removeAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerRemoveAccessV1: async (removeAccessParamsDto: RemoveAccessParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeAccessParamsDto' is not null or undefined
            assertParamExists('accessControllerRemoveAccessV1', 'removeAccessParamsDto', removeAccessParamsDto)
            const localVarPath = `/v1/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccessParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddAccessParamsDto} addAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerAddAccessV1(addAccessParamsDto: AddAccessParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerAddAccessV1(addAccessParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerAddAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} resource 
         * @param {string} resourceId 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerCheckAccessV1(resource: string, resourceId: string, action: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerCheckAccessV1(resource, resourceId, action, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerCheckAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RemoveAccessParamsDto} removeAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessControllerRemoveAccessV1(removeAccessParamsDto: RemoveAccessParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessControllerRemoveAccessV1(removeAccessParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessApi.accessControllerRemoveAccessV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessApiFp(configuration)
    return {
        /**
         * 
         * @param {AddAccessParamsDto} addAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerAddAccessV1(addAccessParamsDto: AddAccessParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerAddAccessV1(addAccessParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} resource 
         * @param {string} resourceId 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerCheckAccessV1(resource: string, resourceId: string, action: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerCheckAccessV1(resource, resourceId, action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveAccessParamsDto} removeAccessParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessControllerRemoveAccessV1(removeAccessParamsDto: RemoveAccessParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accessControllerRemoveAccessV1(removeAccessParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * 
     * @param {AddAccessParamsDto} addAccessParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerAddAccessV1(addAccessParamsDto: AddAccessParamsDto, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerAddAccessV1(addAccessParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} resource 
     * @param {string} resourceId 
     * @param {string} action 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerCheckAccessV1(resource: string, resourceId: string, action: string, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerCheckAccessV1(resource, resourceId, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveAccessParamsDto} removeAccessParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessControllerRemoveAccessV1(removeAccessParamsDto: RemoveAccessParamsDto, options?: RawAxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessControllerRemoveAccessV1(removeAccessParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreateAccountV1: async (createAccountParamsDto: CreateAccountParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountParamsDto' is not null or undefined
            assertParamExists('accountsControllerCreateAccountV1', 'createAccountParamsDto', createAccountParamsDto)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountByAliasV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetAccountByAliasV1', 'id', id)
            const localVarPath = `/v1/accounts/alias/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetAccountV1', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetSelfV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerCreateAccountV1(createAccountParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerCreateAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountByAliasV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountByAliasV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetSelfV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetSelfV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerCreateAccountV1(createAccountParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetAccountByAliasV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetAccountV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetSelfV1(options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetSelfV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAccountParamsDto} createAccountParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerCreateAccountV1(createAccountParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountByAliasV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetSelfV1(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetSelfV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerAddBalanceV1: async (id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('balancesControllerAddBalanceV1', 'id', id)
            // verify required parameter 'addBalanceControllerParamsDto' is not null or undefined
            assertParamExists('balancesControllerAddBalanceV1', 'addBalanceControllerParamsDto', addBalanceControllerParamsDto)
            const localVarPath = `/v1/accounts/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addBalanceControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceForSelfV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts/self/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('balancesControllerGetBalanceV1', 'id', id)
            const localVarPath = `/v1/accounts/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerAddBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerGetBalanceForSelfV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerGetBalanceForSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerGetBalanceV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerGetBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalancesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.balancesControllerGetBalanceForSelfV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.balancesControllerGetBalanceV1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerGetBalanceForSelfV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerGetBalanceV1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallApi - axios parameter creator
 * @export
 */
export const CallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallMethodV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/call`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallApi - functional programming interface
 * @export
 */
export const CallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallMethodV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallMethodV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallMethodV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallApi - factory interface
 * @export
 */
export const CallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallMethodV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.callControllerCallMethodV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallApi - object-oriented interface
 * @export
 * @class CallApi
 * @extends {BaseAPI}
 */
export class CallApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallMethodV1(options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallMethodV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerAddItemsV1: async (id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerAddItemsV1', 'id', id)
            // verify required parameter 'addItemsToCollectionControllerParamsDto' is not null or undefined
            assertParamExists('collectionsControllerAddItemsV1', 'addItemsToCollectionControllerParamsDto', addItemsToCollectionControllerParamsDto)
            const localVarPath = `/v1/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerCreateCollectionV1: async (createCollectionParamsDto: CreateCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCollectionParamsDto' is not null or undefined
            assertParamExists('collectionsControllerCreateCollectionV1', 'createCollectionParamsDto', createCollectionParamsDto)
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerGetCollectionV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerGetCollectionV1', 'id', id)
            const localVarPath = `/v1/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListCollectionsV1: async (orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListItemsV1: async (id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerListItemsV1', 'id', id)
            const localVarPath = `/v1/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerRemoveItemsV1: async (id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerRemoveItemsV1', 'id', id)
            // verify required parameter 'removeItemsFromCollectionControllerParamsDto' is not null or undefined
            assertParamExists('collectionsControllerRemoveItemsV1', 'removeItemsFromCollectionControllerParamsDto', removeItemsFromCollectionControllerParamsDto)
            const localVarPath = `/v1/collections/{id}/items/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('collectionsControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/collections/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerAddItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerCreateCollectionV1(createCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerCreateCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerGetCollectionV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerGetCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerListCollectionsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerListCollectionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionItemsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerListItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerRemoveItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.collectionsControllerCreateCollectionV1(createCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.collectionsControllerGetCollectionV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionsDto> {
            return localVarFp.collectionsControllerListCollectionsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionItemsDto> {
            return localVarFp.collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCollectionParamsDto} createCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerCreateCollectionV1(createCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerGetCollectionV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerListCollectionsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [cursor] 
     * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CollectionsControllerListCollectionsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type CollectionsControllerListCollectionsV1OrderByEnum = typeof CollectionsControllerListCollectionsV1OrderByEnum[keyof typeof CollectionsControllerListCollectionsV1OrderByEnum];
/**
 * @export
 */
export const CollectionsControllerListItemsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type CollectionsControllerListItemsV1OrderByEnum = typeof CollectionsControllerListItemsV1OrderByEnum[keyof typeof CollectionsControllerListItemsV1OrderByEnum];
/**
 * @export
 */
export const CollectionsControllerListItemsV1KindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;
export type CollectionsControllerListItemsV1KindEnum = typeof CollectionsControllerListItemsV1KindEnum[keyof typeof CollectionsControllerListItemsV1KindEnum];


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAddAccountV1: async (id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerAddAccountV1', 'id', id)
            // verify required parameter 'addAccountToGroupControllerParamsDto' is not null or undefined
            assertParamExists('groupsControllerAddAccountV1', 'addAccountToGroupControllerParamsDto', addAccountToGroupControllerParamsDto)
            const localVarPath = `/v1/groups/{id}/accounts/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountToGroupControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroupV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerDeleteGroupV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerDeleteGroupV1', 'id', id)
            const localVarPath = `/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroupV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerGetGroupV1', 'id', id)
            const localVarPath = `/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerRemoveAccountV1: async (id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerRemoveAccountV1', 'id', id)
            // verify required parameter 'removeAccountFromGroupControllerParamsDto' is not null or undefined
            assertParamExists('groupsControllerRemoveAccountV1', 'removeAccountFromGroupControllerParamsDto', removeAccountFromGroupControllerParamsDto)
            const localVarPath = `/v1/groups/{id}/accounts/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountFromGroupControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerAddAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerCreateGroupV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerCreateGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerDeleteGroupV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerDeleteGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerGetGroupV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerGetGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerRemoveAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.groupsControllerCreateGroupV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerDeleteGroupV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.groupsControllerGetGroupV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerCreateGroupV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerDeleteGroupV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerGetGroupV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFinalizeUploadV1: async (createImageParamsDto: CreateImageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createImageParamsDto' is not null or undefined
            assertParamExists('imagesControllerFinalizeUploadV1', 'createImageParamsDto', createImageParamsDto)
            const localVarPath = `/v1/images/upload/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerGetImageV1', 'id', id)
            const localVarPath = `/v1/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetUrlsV1: async (getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUrlsForImagesParamsDto' is not null or undefined
            assertParamExists('imagesControllerGetUrlsV1', 'getUrlsForImagesParamsDto', getUrlsForImagesParamsDto)
            const localVarPath = `/v1/images/urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUrlsForImagesParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerStartUploadV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/images/upload/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerFinalizeUploadV1(createImageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerFinalizeUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetImageV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetImageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageUrlsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetUrlsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerStartUploadV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializeImageUploadResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerStartUploadV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerStartUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.imagesControllerFinalizeUploadV1(createImageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.imagesControllerGetImageV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageUrlsResultDto>> {
            return localVarFp.imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerStartUploadV1(options?: RawAxiosRequestConfig): AxiosPromise<InitializeImageUploadResultDto> {
            return localVarFp.imagesControllerStartUploadV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @param {CreateImageParamsDto} createImageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerFinalizeUploadV1(createImageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetImageV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerStartUploadV1(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerStartUploadV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('operationsControllerGetOperationV1', 'id', id)
            const localVarPath = `/v1/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationsV1: async (getOperationsParamsDto: GetOperationsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOperationsParamsDto' is not null or undefined
            assertParamExists('operationsControllerGetOperationsV1', 'getOperationsParamsDto', getOperationsParamsDto)
            const localVarPath = `/v1/operations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOperationsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerListOperationsV1: async (orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Input} input 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunConstructPromptV1V1: async (input: Input, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'input' is not null or undefined
            assertParamExists('operationsControllerRunConstructPromptV1V1', 'input', input)
            const localVarPath = `/v1/operations/run/constructPrompt.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(input, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('operationsControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('operationsControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/operations/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerGetOperationV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerGetOperationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OperationEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerGetOperationsV1(getOperationsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerGetOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOperationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerListOperationsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerListOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Input} input 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunConstructPromptV1V1(input: Input, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunConstructPromptV1V1(input, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunConstructPromptV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerGetOperationV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<OperationEntity>> {
            return localVarFp.operationsControllerGetOperationsV1(getOperationsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOperationsDto> {
            return localVarFp.operationsControllerListOperationsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Input} input 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunConstructPromptV1V1(input: Input, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunConstructPromptV1V1(input, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.operationsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerGetOperationV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOperationsParamsDto} getOperationsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerGetOperationsV1(getOperationsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerListOperationsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Input} input 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunConstructPromptV1V1(input: Input, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunConstructPromptV1V1(input, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OperationsControllerListOperationsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type OperationsControllerListOperationsV1OrderByEnum = typeof OperationsControllerListOperationsV1OrderByEnum[keyof typeof OperationsControllerListOperationsV1OrderByEnum];


/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerCreatePipelineV1: async (createPipelineParamsDto: CreatePipelineParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPipelineParamsDto' is not null or undefined
            assertParamExists('pipelinesControllerCreatePipelineV1', 'createPipelineParamsDto', createPipelineParamsDto)
            const localVarPath = `/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPipelineParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerGetPipelineV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesControllerGetPipelineV1', 'id', id)
            const localVarPath = `/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerListPipelinesV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerUpdatePipelineV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesControllerUpdatePipelineV1', 'id', id)
            const localVarPath = `/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerCreatePipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerGetPipelineV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerGetPipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerListPipelinesV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerListPipelinesV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerListPipelinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerUpdatePipelineV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerUpdatePipelineV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerUpdatePipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<PipelineEntity> {
            return localVarFp.pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.pipelinesControllerGetPipelineV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerListPipelinesV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.pipelinesControllerListPipelinesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerUpdatePipelineV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.pipelinesControllerUpdatePipelineV1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * 
     * @param {CreatePipelineParamsDto} createPipelineParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerGetPipelineV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerListPipelinesV1(options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerListPipelinesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerUpdatePipelineV1(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerUpdatePipelineV1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PosesApi - axios parameter creator
 * @export
 */
export const PosesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePoseParamsDto} createPoseParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerCreatePoseV1: async (createPoseParamsDto: CreatePoseParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPoseParamsDto' is not null or undefined
            assertParamExists('posesControllerCreatePoseV1', 'createPoseParamsDto', createPoseParamsDto)
            const localVarPath = `/v1/poses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPoseParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerGetPoseV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('posesControllerGetPoseV1', 'id', id)
            const localVarPath = `/v1/poses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerListStacksV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/poses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PosesApi - functional programming interface
 * @export
 */
export const PosesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PosesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePoseParamsDto} createPoseParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerCreatePoseV1(createPoseParamsDto: CreatePoseParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerCreatePoseV1(createPoseParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerCreatePoseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerGetPoseV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerGetPoseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerListStacksV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerListStacksV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerListStacksV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PosesApi - factory interface
 * @export
 */
export const PosesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PosesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePoseParamsDto} createPoseParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerCreatePoseV1(createPoseParamsDto: CreatePoseParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.posesControllerCreatePoseV1(createPoseParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.posesControllerGetPoseV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerListStacksV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.posesControllerListStacksV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PosesApi - object-oriented interface
 * @export
 * @class PosesApi
 * @extends {BaseAPI}
 */
export class PosesApi extends BaseAPI {
    /**
     * 
     * @param {CreatePoseParamsDto} createPoseParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerCreatePoseV1(createPoseParamsDto: CreatePoseParamsDto, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerCreatePoseV1(createPoseParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerGetPoseV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerListStacksV1(options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerListStacksV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StacksApi - axios parameter creator
 * @export
 */
export const StacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddOperationsToStackControllerParamsDto} addOperationsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerAddOperationsV1: async (id: string, addOperationsToStackControllerParamsDto: AddOperationsToStackControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerAddOperationsV1', 'id', id)
            // verify required parameter 'addOperationsToStackControllerParamsDto' is not null or undefined
            assertParamExists('stacksControllerAddOperationsV1', 'addOperationsToStackControllerParamsDto', addOperationsToStackControllerParamsDto)
            const localVarPath = `/v1/stacks/{id}/operations/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOperationsToStackControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerCreateStackV1: async (createStackParamsDto: CreateStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStackParamsDto' is not null or undefined
            assertParamExists('stacksControllerCreateStackV1', 'createStackParamsDto', createStackParamsDto)
            const localVarPath = `/v1/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerGetStackV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerGetStackV1', 'id', id)
            const localVarPath = `/v1/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerListStacksV1: async (orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveOperationsFromStackControllerParamsDto} removeOperationsFromStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerRemoveOperationV1: async (id: string, removeOperationsFromStackControllerParamsDto: RemoveOperationsFromStackControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerRemoveOperationV1', 'id', id)
            // verify required parameter 'removeOperationsFromStackControllerParamsDto' is not null or undefined
            assertParamExists('stacksControllerRemoveOperationV1', 'removeOperationsFromStackControllerParamsDto', removeOperationsFromStackControllerParamsDto)
            const localVarPath = `/v1/stacks/{id}/operations/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeOperationsFromStackControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('stacksControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/stacks/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StacksApi - functional programming interface
 * @export
 */
export const StacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddOperationsToStackControllerParamsDto} addOperationsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerAddOperationsV1(id: string, addOperationsToStackControllerParamsDto: AddOperationsToStackControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerAddOperationsV1(id, addOperationsToStackControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerAddOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerCreateStackV1(createStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerCreateStackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerGetStackV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerGetStackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStacksDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerListStacksV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerListStacksV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveOperationsFromStackControllerParamsDto} removeOperationsFromStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerRemoveOperationV1(id: string, removeOperationsFromStackControllerParamsDto: RemoveOperationsFromStackControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerRemoveOperationV1(id, removeOperationsFromStackControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerRemoveOperationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StacksApi - factory interface
 * @export
 */
export const StacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StacksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddOperationsToStackControllerParamsDto} addOperationsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerAddOperationsV1(id: string, addOperationsToStackControllerParamsDto: AddOperationsToStackControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerAddOperationsV1(id, addOperationsToStackControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerCreateStackV1(createStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerGetStackV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListStacksDto> {
            return localVarFp.stacksControllerListStacksV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveOperationsFromStackControllerParamsDto} removeOperationsFromStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerRemoveOperationV1(id: string, removeOperationsFromStackControllerParamsDto: RemoveOperationsFromStackControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerRemoveOperationV1(id, removeOperationsFromStackControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.stacksControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StacksApi - object-oriented interface
 * @export
 * @class StacksApi
 * @extends {BaseAPI}
 */
export class StacksApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddOperationsToStackControllerParamsDto} addOperationsToStackControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerAddOperationsV1(id: string, addOperationsToStackControllerParamsDto: AddOperationsToStackControllerParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerAddOperationsV1(id, addOperationsToStackControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStackParamsDto} createStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerCreateStackV1(createStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerGetStackV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerListStacksV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveOperationsFromStackControllerParamsDto} removeOperationsFromStackControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerRemoveOperationV1(id: string, removeOperationsFromStackControllerParamsDto: RemoveOperationsFromStackControllerParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerRemoveOperationV1(id, removeOperationsFromStackControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StacksControllerListStacksV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type StacksControllerListStacksV1OrderByEnum = typeof StacksControllerListStacksV1OrderByEnum[keyof typeof StacksControllerListStacksV1OrderByEnum];


/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerCreateRecordV1: async (createStorageRecordParamsDto: CreateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerCreateRecordV1', 'createStorageRecordParamsDto', createStorageRecordParamsDto)
            const localVarPath = `/v1/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerDeleteRecordV1: async (deleteStorageParamsDto: DeleteStorageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteStorageParamsDto' is not null or undefined
            assertParamExists('storageControllerDeleteRecordV1', 'deleteStorageParamsDto', deleteStorageParamsDto)
            const localVarPath = `/v1/storage/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStorageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerGetRecordsV1: async (getStorageRecordParamsDto: GetStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerGetRecordsV1', 'getStorageRecordParamsDto', getStorageRecordParamsDto)
            const localVarPath = `/v1/storage/values`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerUpdateRecordV1: async (updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerUpdateRecordV1', 'updateStorageRecordParamsDto', updateStorageRecordParamsDto)
            const localVarPath = `/v1/storage/write`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerCreateRecordV1(createStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerCreateRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerDeleteRecordV1(deleteStorageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerDeleteRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageRecordsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerGetRecordsV1(getStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerGetRecordsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerUpdateRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.storageControllerCreateRecordV1(createStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storageControllerDeleteRecordV1(deleteStorageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<StorageRecordsResultDto>> {
            return localVarFp.storageControllerGetRecordsV1(getStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageEntity> {
            return localVarFp.storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * 
     * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerCreateRecordV1(createStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerDeleteRecordV1(deleteStorageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerGetRecordsV1(getStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadFileV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadControllerUploadFileV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadControllerUploadFileV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.uploadControllerUploadFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadFileV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadControllerUploadFileV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadFileV1(options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).uploadControllerUploadFileV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebsocketApi - axios parameter creator
 * @export
 */
export const WebsocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerGetSettingsV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/websocket/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerRegisterWebsocketV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/websocket/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsocketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketControllerGetSettingsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsocketApi.websocketControllerGetSettingsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketControllerRegisterWebsocketV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsocketApi.websocketControllerRegisterWebsocketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsocketApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.websocketControllerGetSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.websocketControllerRegisterWebsocketV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketControllerGetSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketControllerRegisterWebsocketV1(options).then((request) => request(this.axios, this.basePath));
    }
}



