/* tslint:disable */
/* eslint-disable */
/**
 * Hautech API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountEntity
 */
export interface AccountEntity {
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountEntity
     */
    'type': AccountEntityTypeEnum;
}

export const AccountEntityTypeEnum = {
    Root: 'root',
    User: 'user'
} as const;

export type AccountEntityTypeEnum = typeof AccountEntityTypeEnum[keyof typeof AccountEntityTypeEnum];

/**
 * 
 * @export
 * @interface AddAccountToGroupControllerParamsDto
 */
export interface AddAccountToGroupControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupControllerParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AddAccountToGroupControllerParamsDto
     */
    'role': AddAccountToGroupControllerParamsDtoRoleEnum;
}

export const AddAccountToGroupControllerParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type AddAccountToGroupControllerParamsDtoRoleEnum = typeof AddAccountToGroupControllerParamsDtoRoleEnum[keyof typeof AddAccountToGroupControllerParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface AddBalanceControllerParamsDto
 */
export interface AddBalanceControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof AddBalanceControllerParamsDto
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface AddItemsToCollectionControllerParamsDto
 */
export interface AddItemsToCollectionControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToCollectionControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddItemsToStackControllerParamsDto
 */
export interface AddItemsToStackControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddItemsToStackControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface BalanceResultDto
 */
export interface BalanceResultDto {
    /**
     * 
     * @type {string}
     * @memberof BalanceResultDto
     */
    'balance': string;
}
/**
 * 
 * @export
 * @interface CollectionEntity
 */
export interface CollectionEntity {
    /**
     * 
     * @type {number}
     * @memberof CollectionEntity
     */
    'kind': number;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof CollectionEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CollectionEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CreateAccountParamsDto
 */
export interface CreateAccountParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountParamsDto
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionParamsDto
 */
export interface CreateCollectionParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateCollectionParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CreateImageParamsDto
 */
export interface CreateImageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateImageParamsDto
     */
    'fileToken'?: string;
}
/**
 * 
 * @export
 * @interface CreatePipelineParamsDto
 */
export interface CreatePipelineParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'metadata'?: object;
    /**
     * 
     * @type {object}
     * @memberof CreatePipelineParamsDto
     */
    'tasks': object;
}
/**
 * 
 * @export
 * @interface CreateStackParamsDto
 */
export interface CreateStackParamsDto {
    /**
     * 
     * @type {object}
     * @memberof CreateStackParamsDto
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface CreateStorageRecordParamsDto
 */
export interface CreateStorageRecordParamsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateStorageRecordParamsDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof CreateStorageRecordParamsDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface DeleteStorageParamsDto
 */
export interface DeleteStorageParamsDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteStorageParamsDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface GPTV1ControllerInput
 */
export interface GPTV1ControllerInput {
    /**
     * 
     * @type {GPTV1Input}
     * @memberof GPTV1ControllerInput
     */
    'input'?: GPTV1Input;
    /**
     * 
     * @type {object}
     * @memberof GPTV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface GPTV1Input
 */
export interface GPTV1Input {
    /**
     * 
     * @type {string}
     * @memberof GPTV1Input
     */
    'model'?: GPTV1InputModelEnum;
    /**
     * 
     * @type {string}
     * @memberof GPTV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof GPTV1Input
     */
    'imageId'?: string;
}

export const GPTV1InputModelEnum = {
    Gpt4o: 'gpt-4o'
} as const;

export type GPTV1InputModelEnum = typeof GPTV1InputModelEnum[keyof typeof GPTV1InputModelEnum];

/**
 * 
 * @export
 * @interface GenerateV1ControllerInput
 */
export interface GenerateV1ControllerInput {
    /**
     * 
     * @type {GenerateV1Input}
     * @memberof GenerateV1ControllerInput
     */
    'input'?: GenerateV1Input;
    /**
     * 
     * @type {object}
     * @memberof GenerateV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface GenerateV1Input
 */
export interface GenerateV1Input {
    /**
     * 
     * @type {string}
     * @memberof GenerateV1Input
     */
    'aspectRatio': GenerateV1InputAspectRatioEnum;
    /**
     * 
     * @type {string}
     * @memberof GenerateV1Input
     */
    'productImageId': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {number}
     * @memberof GenerateV1Input
     */
    'seed': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV1Input
     */
    'imageWeight': number;
    /**
     * 
     * @type {string}
     * @memberof GenerateV1Input
     */
    'negativePrompt': string;
    /**
     * 
     * @type {number}
     * @memberof GenerateV1Input
     */
    'inferenceSteps': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV1Input
     */
    'guidanceScale': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV1Input
     */
    'strength': number;
}

export const GenerateV1InputAspectRatioEnum = {
    _11: '1:1',
    _97: '9:7',
    _79: '7:9',
    _1913: '19:13',
    _1319: '13:19',
    _74: '7:4',
    _47: '4:7',
    _125: '12:5',
    _512: '5:12'
} as const;

export type GenerateV1InputAspectRatioEnum = typeof GenerateV1InputAspectRatioEnum[keyof typeof GenerateV1InputAspectRatioEnum];

/**
 * 
 * @export
 * @interface GenerateV3ControllerInput
 */
export interface GenerateV3ControllerInput {
    /**
     * 
     * @type {GenerateV3Input}
     * @memberof GenerateV3ControllerInput
     */
    'input'?: GenerateV3Input;
    /**
     * 
     * @type {object}
     * @memberof GenerateV3ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface GenerateV3Input
 */
export interface GenerateV3Input {
    /**
     * 
     * @type {string}
     * @memberof GenerateV3Input
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateV3Input
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateV3Input
     */
    'garmentImage': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateV3Input
     */
    'poseImage': string;
    /**
     * 
     * @type {number}
     * @memberof GenerateV3Input
     */
    'seed': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV3Input
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV3Input
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV3Input
     */
    'textGuidanceScale': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV3Input
     */
    'imageGuidanceScale': number;
    /**
     * 
     * @type {number}
     * @memberof GenerateV3Input
     */
    'numInferenceSteps': number;
}
/**
 * 
 * @export
 * @interface GetOperationsParamsDto
 */
export interface GetOperationsParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetOperationsParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GetStorageRecordParamsDto
 */
export interface GetStorageRecordParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetStorageRecordParamsDto
     */
    'keys': Array<string>;
}
/**
 * 
 * @export
 * @interface GetUrlsForImagesParamsDto
 */
export interface GetUrlsForImagesParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUrlsForImagesParamsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupEntity
 */
export interface GroupEntity {
    /**
     * 
     * @type {string}
     * @memberof GroupEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupEntity
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ImageEntity
 */
export interface ImageEntity {
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'kind': ImageEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ImageEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof ImageEntity
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ImageEntity
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof ImageEntity
     */
    'format': string;
}

export const ImageEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type ImageEntityKindEnum = typeof ImageEntityKindEnum[keyof typeof ImageEntityKindEnum];

/**
 * 
 * @export
 * @interface ImageRepresentationResponseDto
 */
export interface ImageRepresentationResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ImageRepresentationResponseDto
     */
    'imageId': string;
    /**
     * 
     * @type {string}
     * @memberof ImageRepresentationResponseDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ImageRepresentationResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImageUrlResponseDto
 */
export interface ImageUrlResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ImageUrlResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrlResponseDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImagineV1ControllerInput
 */
export interface ImagineV1ControllerInput {
    /**
     * 
     * @type {ImagineV1Input}
     * @memberof ImagineV1ControllerInput
     */
    'input'?: ImagineV1Input;
    /**
     * 
     * @type {object}
     * @memberof ImagineV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ImagineV1Input
 */
export interface ImagineV1Input {
    /**
     * 
     * @type {string}
     * @memberof ImagineV1Input
     */
    'aspectRatio': ImagineV1InputAspectRatioEnum;
    /**
     * 
     * @type {string}
     * @memberof ImagineV1Input
     */
    'seed': string;
    /**
     * 
     * @type {string}
     * @memberof ImagineV1Input
     */
    'prompt': string;
}

export const ImagineV1InputAspectRatioEnum = {
    _11: '1:1',
    _97: '9:7',
    _79: '7:9',
    _1913: '19:13',
    _1319: '13:19',
    _74: '7:4',
    _47: '4:7',
    _125: '12:5',
    _512: '5:12'
} as const;

export type ImagineV1InputAspectRatioEnum = typeof ImagineV1InputAspectRatioEnum[keyof typeof ImagineV1InputAspectRatioEnum];

/**
 * 
 * @export
 * @interface InitializeImageUploadResultDto
 */
export interface InitializeImageUploadResultDto {
    /**
     * 
     * @type {string}
     * @memberof InitializeImageUploadResultDto
     */
    'uploadUrl': string;
}
/**
 * 
 * @export
 * @interface InpaintV1ControllerInput
 */
export interface InpaintV1ControllerInput {
    /**
     * 
     * @type {InpaintV1Input}
     * @memberof InpaintV1ControllerInput
     */
    'input'?: InpaintV1Input;
    /**
     * 
     * @type {object}
     * @memberof InpaintV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface InpaintV1Input
 */
export interface InpaintV1Input {
    /**
     * 
     * @type {string}
     * @memberof InpaintV1Input
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof InpaintV1Input
     */
    'mask': string;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'maskSpread': number;
    /**
     * 
     * @type {string}
     * @memberof InpaintV1Input
     */
    'prompt': string;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'seed': number;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'strength': number;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'numInferenceSteps': number;
    /**
     * 
     * @type {number}
     * @memberof InpaintV1Input
     */
    'guidanceScale': number;
}
/**
 * 
 * @export
 * @interface ListCollectionItemsDto
 */
export interface ListCollectionItemsDto {
    /**
     * 
     * @type {Array<ResourceEntity>}
     * @memberof ListCollectionItemsDto
     */
    'data': Array<ResourceEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListCollectionItemsDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListCollectionsDto
 */
export interface ListCollectionsDto {
    /**
     * 
     * @type {Array<CollectionEntity>}
     * @memberof ListCollectionsDto
     */
    'data': Array<CollectionEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListCollectionsDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListCollectionsDtoPageInfo
 */
export interface ListCollectionsDtoPageInfo {
    /**
     * 
     * @type {string}
     * @memberof ListCollectionsDtoPageInfo
     */
    'nextCursor': string;
}
/**
 * 
 * @export
 * @interface ListOperationsDto
 */
export interface ListOperationsDto {
    /**
     * 
     * @type {Array<OperationEntity>}
     * @memberof ListOperationsDto
     */
    'data': Array<OperationEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListOperationsDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListPosesDto
 */
export interface ListPosesDto {
    /**
     * 
     * @type {Array<PoseEntity>}
     * @memberof ListPosesDto
     */
    'data': Array<PoseEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListPosesDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ListStacksDto
 */
export interface ListStacksDto {
    /**
     * 
     * @type {Array<StackEntity>}
     * @memberof ListStacksDto
     */
    'data': Array<StackEntity>;
    /**
     * 
     * @type {ListCollectionsDtoPageInfo}
     * @memberof ListStacksDto
     */
    'pageInfo': ListCollectionsDtoPageInfo;
}
/**
 * 
 * @export
 * @interface ObjectDetectionV1ControllerInput
 */
export interface ObjectDetectionV1ControllerInput {
    /**
     * 
     * @type {ObjectDetectionV1Input}
     * @memberof ObjectDetectionV1ControllerInput
     */
    'input'?: ObjectDetectionV1Input;
    /**
     * 
     * @type {object}
     * @memberof ObjectDetectionV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ObjectDetectionV1Input
 */
export interface ObjectDetectionV1Input {
    /**
     * 
     * @type {Array<string>}
     * @memberof ObjectDetectionV1Input
     */
    'labels': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ObjectDetectionV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface OperationEntity
 */
export interface OperationEntity {
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'kind': OperationEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'input': object;
    /**
     * 
     * @type {object}
     * @memberof OperationEntity
     */
    'output': object | null;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'status': OperationEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationEntity
     */
    'type': string;
}

export const OperationEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type OperationEntityKindEnum = typeof OperationEntityKindEnum[keyof typeof OperationEntityKindEnum];
export const OperationEntityStatusEnum = {
    Pending: 'pending',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type OperationEntityStatusEnum = typeof OperationEntityStatusEnum[keyof typeof OperationEntityStatusEnum];

/**
 * 
 * @export
 * @interface PipelineEntity
 */
export interface PipelineEntity {
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'kind': PipelineEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'permissions': object;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'state': object;
    /**
     * 
     * @type {string}
     * @memberof PipelineEntity
     */
    'status': PipelineEntityStatusEnum;
    /**
     * 
     * @type {object}
     * @memberof PipelineEntity
     */
    'tasks': object;
}

export const PipelineEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type PipelineEntityKindEnum = typeof PipelineEntityKindEnum[keyof typeof PipelineEntityKindEnum];
export const PipelineEntityStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Success: 'success',
    Failed: 'failed'
} as const;

export type PipelineEntityStatusEnum = typeof PipelineEntityStatusEnum[keyof typeof PipelineEntityStatusEnum];

/**
 * 
 * @export
 * @interface PoseEntity
 */
export interface PoseEntity {
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'kind': PoseEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof PoseEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {ImageEntity}
     * @memberof PoseEntity
     */
    'sourceImage': ImageEntity;
    /**
     * 
     * @type {ImageEntity}
     * @memberof PoseEntity
     */
    'previewImage': ImageEntity;
    /**
     * 
     * @type {string}
     * @memberof PoseEntity
     */
    'previewImageId': string;
}

export const PoseEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type PoseEntityKindEnum = typeof PoseEntityKindEnum[keyof typeof PoseEntityKindEnum];

/**
 * 
 * @export
 * @interface PoseEstimationV1ControllerInput
 */
export interface PoseEstimationV1ControllerInput {
    /**
     * 
     * @type {PoseEstimationV1Input}
     * @memberof PoseEstimationV1ControllerInput
     */
    'input'?: PoseEstimationV1Input;
    /**
     * 
     * @type {object}
     * @memberof PoseEstimationV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface PoseEstimationV1Input
 */
export interface PoseEstimationV1Input {
    /**
     * 
     * @type {string}
     * @memberof PoseEstimationV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface RemoveAccountFromGroupControllerParamsDto
 */
export interface RemoveAccountFromGroupControllerParamsDto {
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupControllerParamsDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveAccountFromGroupControllerParamsDto
     */
    'role': RemoveAccountFromGroupControllerParamsDtoRoleEnum;
}

export const RemoveAccountFromGroupControllerParamsDtoRoleEnum = {
    Maintainer: 'maintainer',
    Member: 'member',
    Owner: 'owner'
} as const;

export type RemoveAccountFromGroupControllerParamsDtoRoleEnum = typeof RemoveAccountFromGroupControllerParamsDtoRoleEnum[keyof typeof RemoveAccountFromGroupControllerParamsDtoRoleEnum];

/**
 * 
 * @export
 * @interface RemoveItemsFromCollectionControllerParamsDto
 */
export interface RemoveItemsFromCollectionControllerParamsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveItemsFromCollectionControllerParamsDto
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ResourceEntity
 */
export interface ResourceEntity {
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'kind': ResourceEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof ResourceEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceEntity
     */
    'updatedAt': string;
}

export const ResourceEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type ResourceEntityKindEnum = typeof ResourceEntityKindEnum[keyof typeof ResourceEntityKindEnum];

/**
 * 
 * @export
 * @interface SegmentAnythingEmbeddingsV1ControllerInput
 */
export interface SegmentAnythingEmbeddingsV1ControllerInput {
    /**
     * 
     * @type {SegmentAnythingEmbeddingsV1Input}
     * @memberof SegmentAnythingEmbeddingsV1ControllerInput
     */
    'input'?: SegmentAnythingEmbeddingsV1Input;
    /**
     * 
     * @type {object}
     * @memberof SegmentAnythingEmbeddingsV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface SegmentAnythingEmbeddingsV1Input
 */
export interface SegmentAnythingEmbeddingsV1Input {
    /**
     * 
     * @type {string}
     * @memberof SegmentAnythingEmbeddingsV1Input
     */
    'imageId': string;
}
/**
 * 
 * @export
 * @interface StackEntity
 */
export interface StackEntity {
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'kind': StackEntityKindEnum;
    /**
     * 
     * @type {Array<StackEntityItemsInner>}
     * @memberof StackEntity
     */
    'items': Array<StackEntityItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StackEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StackEntity
     */
    'updatedAt': string;
}

export const StackEntityKindEnum = {
    Stack: 'stack'
} as const;

export type StackEntityKindEnum = typeof StackEntityKindEnum[keyof typeof StackEntityKindEnum];

/**
 * @type StackEntityItemsInner
 * @export
 */
export type StackEntityItemsInner = ImageEntity | OperationEntity;

/**
 * 
 * @export
 * @interface StorageEntity
 */
export interface StorageEntity {
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'kind': StorageEntityKindEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'creatorId': string;
    /**
     * 
     * @type {object}
     * @memberof StorageEntity
     */
    'metadata': object;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof StorageEntity
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof StorageEntity
     */
    'value': object;
}

export const StorageEntityKindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;

export type StorageEntityKindEnum = typeof StorageEntityKindEnum[keyof typeof StorageEntityKindEnum];

/**
 * 
 * @export
 * @interface StorageRecordsResultDto
 */
export interface StorageRecordsResultDto {
    /**
     * 
     * @type {string}
     * @memberof StorageRecordsResultDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof StorageRecordsResultDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface UpdateMetadataDto
 */
export interface UpdateMetadataDto {
    /**
     * 
     * @type {object}
     * @memberof UpdateMetadataDto
     */
    'overwrite': object;
}
/**
 * 
 * @export
 * @interface UpdateStorageRecordParamsDto
 */
export interface UpdateStorageRecordParamsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateStorageRecordParamsDto
     */
    'key': string;
    /**
     * 
     * @type {object}
     * @memberof UpdateStorageRecordParamsDto
     */
    'value': object;
}
/**
 * 
 * @export
 * @interface UpscaleV1ControllerInput
 */
export interface UpscaleV1ControllerInput {
    /**
     * 
     * @type {UpscaleV1Input}
     * @memberof UpscaleV1ControllerInput
     */
    'input'?: UpscaleV1Input;
    /**
     * 
     * @type {object}
     * @memberof UpscaleV1ControllerInput
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface UpscaleV1Input
 */
export interface UpscaleV1Input {
    /**
     * 
     * @type {string}
     * @memberof UpscaleV1Input
     */
    'imageId': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreateAccountV1: async (createAccountParamsDto: CreateAccountParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountParamsDto' is not null or undefined
            assertParamExists('accountsControllerCreateAccountV1', 'createAccountParamsDto', createAccountParamsDto)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountByAliasV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetAccountByAliasV1', 'id', id)
            const localVarPath = `/v1/accounts/alias/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetAccountV1', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetSelfV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerCreateAccountV1(createAccountParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerCreateAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountByAliasV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountByAliasV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAccountV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetSelfV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetSelfV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.accountsControllerGetSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAccountParamsDto} createAccountParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerCreateAccountV1(createAccountParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetAccountByAliasV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetAccountV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetSelfV1(options?: RawAxiosRequestConfig): AxiosPromise<AccountEntity> {
            return localVarFp.accountsControllerGetSelfV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAccountParamsDto} createAccountParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerCreateAccountV1(createAccountParamsDto: CreateAccountParamsDto, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerCreateAccountV1(createAccountParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountByAliasV1(id: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountByAliasV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAccountV1(id: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAccountV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetSelfV1(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetSelfV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerAddBalanceV1: async (id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('balancesControllerAddBalanceV1', 'id', id)
            // verify required parameter 'addBalanceControllerParamsDto' is not null or undefined
            assertParamExists('balancesControllerAddBalanceV1', 'addBalanceControllerParamsDto', addBalanceControllerParamsDto)
            const localVarPath = `/v1/accounts/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addBalanceControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceForSelfV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts/self/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('balancesControllerGetBalanceV1', 'id', id)
            const localVarPath = `/v1/accounts/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerAddBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerGetBalanceForSelfV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerGetBalanceForSelfV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesControllerGetBalanceV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.balancesControllerGetBalanceV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalancesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.balancesControllerGetBalanceForSelfV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BalanceResultDto> {
            return localVarFp.balancesControllerGetBalanceV1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddBalanceControllerParamsDto} addBalanceControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerAddBalanceV1(id: string, addBalanceControllerParamsDto: AddBalanceControllerParamsDto, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerAddBalanceV1(id, addBalanceControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerGetBalanceForSelfV1(options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerGetBalanceForSelfV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public balancesControllerGetBalanceV1(id: string, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).balancesControllerGetBalanceV1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallApi - axios parameter creator
 * @export
 */
export const CallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallMethodV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/call`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallApi - functional programming interface
 * @export
 */
export const CallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callControllerCallMethodV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callControllerCallMethodV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallApi.callControllerCallMethodV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallApi - factory interface
 * @export
 */
export const CallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callControllerCallMethodV1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.callControllerCallMethodV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallApi - object-oriented interface
 * @export
 * @class CallApi
 * @extends {BaseAPI}
 */
export class CallApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public callControllerCallMethodV1(options?: RawAxiosRequestConfig) {
        return CallApiFp(this.configuration).callControllerCallMethodV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerAddItemsV1: async (id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerAddItemsV1', 'id', id)
            // verify required parameter 'addItemsToCollectionControllerParamsDto' is not null or undefined
            assertParamExists('collectionsControllerAddItemsV1', 'addItemsToCollectionControllerParamsDto', addItemsToCollectionControllerParamsDto)
            const localVarPath = `/v1/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerCreateCollectionV1: async (createCollectionParamsDto: CreateCollectionParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCollectionParamsDto' is not null or undefined
            assertParamExists('collectionsControllerCreateCollectionV1', 'createCollectionParamsDto', createCollectionParamsDto)
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerGetCollectionV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerGetCollectionV1', 'id', id)
            const localVarPath = `/v1/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListCollectionsV1: async (orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListItemsV1: async (id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerListItemsV1', 'id', id)
            const localVarPath = `/v1/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerRemoveItemsV1: async (id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerRemoveItemsV1', 'id', id)
            // verify required parameter 'removeItemsFromCollectionControllerParamsDto' is not null or undefined
            assertParamExists('collectionsControllerRemoveItemsV1', 'removeItemsFromCollectionControllerParamsDto', removeItemsFromCollectionControllerParamsDto)
            const localVarPath = `/v1/collections/{id}/items/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collectionsControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('collectionsControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/collections/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerAddItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerCreateCollectionV1(createCollectionParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerCreateCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerGetCollectionV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerGetCollectionV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerListCollectionsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerListCollectionsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionItemsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerListItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerRemoveItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.collectionsControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateCollectionParamsDto} createCollectionParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.collectionsControllerCreateCollectionV1(createCollectionParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionEntity> {
            return localVarFp.collectionsControllerGetCollectionV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionsDto> {
            return localVarFp.collectionsControllerListCollectionsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [cursor] 
         * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListCollectionItemsDto> {
            return localVarFp.collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddItemsToCollectionControllerParamsDto} addItemsToCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerAddItemsV1(id: string, addItemsToCollectionControllerParamsDto: AddItemsToCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerAddItemsV1(id, addItemsToCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateCollectionParamsDto} createCollectionParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerCreateCollectionV1(createCollectionParamsDto: CreateCollectionParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerCreateCollectionV1(createCollectionParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerGetCollectionV1(id: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerGetCollectionV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionsControllerListCollectionsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerListCollectionsV1(orderBy?: CollectionsControllerListCollectionsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerListCollectionsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [cursor] 
     * @param {CollectionsControllerListItemsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {CollectionsControllerListItemsV1KindEnum} [kind] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerListItemsV1(id: string, cursor?: string, orderBy?: CollectionsControllerListItemsV1OrderByEnum, limit?: number, kind?: CollectionsControllerListItemsV1KindEnum, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerListItemsV1(id, cursor, orderBy, limit, kind, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CollectionsControllerListCollectionsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type CollectionsControllerListCollectionsV1OrderByEnum = typeof CollectionsControllerListCollectionsV1OrderByEnum[keyof typeof CollectionsControllerListCollectionsV1OrderByEnum];
/**
 * @export
 */
export const CollectionsControllerListItemsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type CollectionsControllerListItemsV1OrderByEnum = typeof CollectionsControllerListItemsV1OrderByEnum[keyof typeof CollectionsControllerListItemsV1OrderByEnum];
/**
 * @export
 */
export const CollectionsControllerListItemsV1KindEnum = {
    Collection: 'collection',
    Operation: 'operation',
    Stack: 'stack',
    Image: 'image',
    Pose: 'pose',
    Storage: 'storage'
} as const;
export type CollectionsControllerListItemsV1KindEnum = typeof CollectionsControllerListItemsV1KindEnum[keyof typeof CollectionsControllerListItemsV1KindEnum];


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAddAccountV1: async (id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerAddAccountV1', 'id', id)
            // verify required parameter 'addAccountToGroupControllerParamsDto' is not null or undefined
            assertParamExists('groupsControllerAddAccountV1', 'addAccountToGroupControllerParamsDto', addAccountToGroupControllerParamsDto)
            const localVarPath = `/v1/groups/{id}/accounts/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountToGroupControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroupV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerDeleteGroupV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerDeleteGroupV1', 'id', id)
            const localVarPath = `/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroupV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerGetGroupV1', 'id', id)
            const localVarPath = `/v1/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerRemoveAccountV1: async (id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsControllerRemoveAccountV1', 'id', id)
            // verify required parameter 'removeAccountFromGroupControllerParamsDto' is not null or undefined
            assertParamExists('groupsControllerRemoveAccountV1', 'removeAccountFromGroupControllerParamsDto', removeAccountFromGroupControllerParamsDto)
            const localVarPath = `/v1/groups/{id}/accounts/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAccountFromGroupControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerAddAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerCreateGroupV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerCreateGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerDeleteGroupV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerDeleteGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerGetGroupV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerGetGroupV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsControllerRemoveAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.groupsControllerCreateGroupV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerDeleteGroupV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupEntity> {
            return localVarFp.groupsControllerGetGroupV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddAccountToGroupControllerParamsDto} addAccountToGroupControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerAddAccountV1(id: string, addAccountToGroupControllerParamsDto: AddAccountToGroupControllerParamsDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerAddAccountV1(id, addAccountToGroupControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerCreateGroupV1(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerCreateGroupV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerDeleteGroupV1(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerDeleteGroupV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetGroupV1(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerGetGroupV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveAccountFromGroupControllerParamsDto} removeAccountFromGroupControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerRemoveAccountV1(id: string, removeAccountFromGroupControllerParamsDto: RemoveAccountFromGroupControllerParamsDto, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsControllerRemoveAccountV1(id, removeAccountFromGroupControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFinalizeUploadV1: async (createImageParamsDto: CreateImageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createImageParamsDto' is not null or undefined
            assertParamExists('imagesControllerFinalizeUploadV1', 'createImageParamsDto', createImageParamsDto)
            const localVarPath = `/v1/images/upload/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerGetImageV1', 'id', id)
            const localVarPath = `/v1/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetRepresentationV1: async (id: string, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesControllerGetRepresentationV1', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('imagesControllerGetRepresentationV1', 'type', type)
            const localVarPath = `/v1/images/{id}/representation/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetUrlsV1: async (getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUrlsForImagesParamsDto' is not null or undefined
            assertParamExists('imagesControllerGetUrlsV1', 'getUrlsForImagesParamsDto', getUrlsForImagesParamsDto)
            const localVarPath = `/v1/images/urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUrlsForImagesParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerStartUploadV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/images/upload/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerFinalizeUploadV1(createImageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerFinalizeUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetImageV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetImageV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetRepresentationV1(id: string, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageRepresentationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetRepresentationV1(id, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetRepresentationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageUrlResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetUrlsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerStartUploadV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializeImageUploadResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerStartUploadV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerStartUploadV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateImageParamsDto} createImageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.imagesControllerFinalizeUploadV1(createImageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageEntity> {
            return localVarFp.imagesControllerGetImageV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetRepresentationV1(id: string, type: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageRepresentationResponseDto> {
            return localVarFp.imagesControllerGetRepresentationV1(id, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageUrlResponseDto>> {
            return localVarFp.imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerStartUploadV1(options?: RawAxiosRequestConfig): AxiosPromise<InitializeImageUploadResultDto> {
            return localVarFp.imagesControllerStartUploadV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @param {CreateImageParamsDto} createImageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerFinalizeUploadV1(createImageParamsDto: CreateImageParamsDto, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerFinalizeUploadV1(createImageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetImageV1(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetImageV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetRepresentationV1(id: string, type: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetRepresentationV1(id, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetUrlsForImagesParamsDto} getUrlsForImagesParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetUrlsV1(getUrlsForImagesParamsDto: GetUrlsForImagesParamsDto, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetUrlsV1(getUrlsForImagesParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerStartUploadV1(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerStartUploadV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('operationsControllerGetOperationV1', 'id', id)
            const localVarPath = `/v1/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationsV1: async (getOperationsParamsDto: GetOperationsParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getOperationsParamsDto' is not null or undefined
            assertParamExists('operationsControllerGetOperationsV1', 'getOperationsParamsDto', getOperationsParamsDto)
            const localVarPath = `/v1/operations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOperationsParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerListOperationsV1: async (orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateV1ControllerInput} generateV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGenerateV1V1: async (generateV1ControllerInput: GenerateV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunGenerateV1V1', 'generateV1ControllerInput', generateV1ControllerInput)
            const localVarPath = `/v1/operations/run/generate.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateV3ControllerInput} generateV3ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGenerateV3V1: async (generateV3ControllerInput: GenerateV3ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateV3ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunGenerateV3V1', 'generateV3ControllerInput', generateV3ControllerInput)
            const localVarPath = `/v1/operations/run/generate.v3`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateV3ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GPTV1ControllerInput} gPTV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGptV1V1: async (gPTV1ControllerInput: GPTV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gPTV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunGptV1V1', 'gPTV1ControllerInput', gPTV1ControllerInput)
            const localVarPath = `/v1/operations/run/gpt.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gPTV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImagineV1ControllerInput} imagineV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunImagineV1V1: async (imagineV1ControllerInput: ImagineV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagineV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunImagineV1V1', 'imagineV1ControllerInput', imagineV1ControllerInput)
            const localVarPath = `/v1/operations/run/imagine.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagineV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InpaintV1ControllerInput} inpaintV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunInpaintV1V1: async (inpaintV1ControllerInput: InpaintV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inpaintV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunInpaintV1V1', 'inpaintV1ControllerInput', inpaintV1ControllerInput)
            const localVarPath = `/v1/operations/run/inpaint.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inpaintV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ObjectDetectionV1ControllerInput} objectDetectionV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunObjectDetectionV1V1: async (objectDetectionV1ControllerInput: ObjectDetectionV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectDetectionV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunObjectDetectionV1V1', 'objectDetectionV1ControllerInput', objectDetectionV1ControllerInput)
            const localVarPath = `/v1/operations/run/objectDetection.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectDetectionV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PoseEstimationV1ControllerInput} poseEstimationV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunPoseEstimationV1V1: async (poseEstimationV1ControllerInput: PoseEstimationV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poseEstimationV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunPoseEstimationV1V1', 'poseEstimationV1ControllerInput', poseEstimationV1ControllerInput)
            const localVarPath = `/v1/operations/run/poseEstimation.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(poseEstimationV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1ControllerInput} segmentAnythingEmbeddingsV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunSegmentAnythingEmbeddingsV1V1: async (segmentAnythingEmbeddingsV1ControllerInput: SegmentAnythingEmbeddingsV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentAnythingEmbeddingsV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunSegmentAnythingEmbeddingsV1V1', 'segmentAnythingEmbeddingsV1ControllerInput', segmentAnythingEmbeddingsV1ControllerInput)
            const localVarPath = `/v1/operations/run/segmentAnything.embeddings.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentAnythingEmbeddingsV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpscaleV1ControllerInput} upscaleV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunUpscaleV1V1: async (upscaleV1ControllerInput: UpscaleV1ControllerInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upscaleV1ControllerInput' is not null or undefined
            assertParamExists('operationsControllerRunUpscaleV1V1', 'upscaleV1ControllerInput', upscaleV1ControllerInput)
            const localVarPath = `/v1/operations/run/upscale.v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upscaleV1ControllerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('operationsControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('operationsControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/operations/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerGetOperationV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerGetOperationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OperationEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerGetOperationsV1(getOperationsParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerGetOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOperationsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerListOperationsV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerListOperationsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenerateV1ControllerInput} generateV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunGenerateV1V1(generateV1ControllerInput: GenerateV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunGenerateV1V1(generateV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunGenerateV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenerateV3ControllerInput} generateV3ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunGenerateV3V1(generateV3ControllerInput: GenerateV3ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunGenerateV3V1(generateV3ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunGenerateV3V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GPTV1ControllerInput} gPTV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunGptV1V1(gPTV1ControllerInput: GPTV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunGptV1V1(gPTV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunGptV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ImagineV1ControllerInput} imagineV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunImagineV1V1(imagineV1ControllerInput: ImagineV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunImagineV1V1(imagineV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunImagineV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InpaintV1ControllerInput} inpaintV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunInpaintV1V1(inpaintV1ControllerInput: InpaintV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunInpaintV1V1(inpaintV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunInpaintV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ObjectDetectionV1ControllerInput} objectDetectionV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunObjectDetectionV1V1(objectDetectionV1ControllerInput: ObjectDetectionV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunObjectDetectionV1V1(objectDetectionV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunObjectDetectionV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PoseEstimationV1ControllerInput} poseEstimationV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunPoseEstimationV1V1(poseEstimationV1ControllerInput: PoseEstimationV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunPoseEstimationV1V1(poseEstimationV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunPoseEstimationV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1ControllerInput} segmentAnythingEmbeddingsV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1ControllerInput: SegmentAnythingEmbeddingsV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunSegmentAnythingEmbeddingsV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpscaleV1ControllerInput} upscaleV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerRunUpscaleV1V1(upscaleV1ControllerInput: UpscaleV1ControllerInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerRunUpscaleV1V1(upscaleV1ControllerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerRunUpscaleV1V1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operationsControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.operationsControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerGetOperationV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetOperationsParamsDto} getOperationsParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<OperationEntity>> {
            return localVarFp.operationsControllerGetOperationsV1(getOperationsParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListOperationsDto> {
            return localVarFp.operationsControllerListOperationsV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateV1ControllerInput} generateV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGenerateV1V1(generateV1ControllerInput: GenerateV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunGenerateV1V1(generateV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateV3ControllerInput} generateV3ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGenerateV3V1(generateV3ControllerInput: GenerateV3ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunGenerateV3V1(generateV3ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GPTV1ControllerInput} gPTV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunGptV1V1(gPTV1ControllerInput: GPTV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunGptV1V1(gPTV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImagineV1ControllerInput} imagineV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunImagineV1V1(imagineV1ControllerInput: ImagineV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunImagineV1V1(imagineV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InpaintV1ControllerInput} inpaintV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunInpaintV1V1(inpaintV1ControllerInput: InpaintV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunInpaintV1V1(inpaintV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ObjectDetectionV1ControllerInput} objectDetectionV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunObjectDetectionV1V1(objectDetectionV1ControllerInput: ObjectDetectionV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunObjectDetectionV1V1(objectDetectionV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PoseEstimationV1ControllerInput} poseEstimationV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunPoseEstimationV1V1(poseEstimationV1ControllerInput: PoseEstimationV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunPoseEstimationV1V1(poseEstimationV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SegmentAnythingEmbeddingsV1ControllerInput} segmentAnythingEmbeddingsV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1ControllerInput: SegmentAnythingEmbeddingsV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpscaleV1ControllerInput} upscaleV1ControllerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerRunUpscaleV1V1(upscaleV1ControllerInput: UpscaleV1ControllerInput, options?: RawAxiosRequestConfig): AxiosPromise<OperationEntity> {
            return localVarFp.operationsControllerRunUpscaleV1V1(upscaleV1ControllerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.operationsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerGetOperationV1(id: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerGetOperationV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetOperationsParamsDto} getOperationsParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerGetOperationsV1(getOperationsParamsDto: GetOperationsParamsDto, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerGetOperationsV1(getOperationsParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OperationsControllerListOperationsV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerListOperationsV1(orderBy?: OperationsControllerListOperationsV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerListOperationsV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateV1ControllerInput} generateV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunGenerateV1V1(generateV1ControllerInput: GenerateV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunGenerateV1V1(generateV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateV3ControllerInput} generateV3ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunGenerateV3V1(generateV3ControllerInput: GenerateV3ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunGenerateV3V1(generateV3ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GPTV1ControllerInput} gPTV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunGptV1V1(gPTV1ControllerInput: GPTV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunGptV1V1(gPTV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImagineV1ControllerInput} imagineV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunImagineV1V1(imagineV1ControllerInput: ImagineV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunImagineV1V1(imagineV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InpaintV1ControllerInput} inpaintV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunInpaintV1V1(inpaintV1ControllerInput: InpaintV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunInpaintV1V1(inpaintV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ObjectDetectionV1ControllerInput} objectDetectionV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunObjectDetectionV1V1(objectDetectionV1ControllerInput: ObjectDetectionV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunObjectDetectionV1V1(objectDetectionV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PoseEstimationV1ControllerInput} poseEstimationV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunPoseEstimationV1V1(poseEstimationV1ControllerInput: PoseEstimationV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunPoseEstimationV1V1(poseEstimationV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SegmentAnythingEmbeddingsV1ControllerInput} segmentAnythingEmbeddingsV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1ControllerInput: SegmentAnythingEmbeddingsV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunSegmentAnythingEmbeddingsV1V1(segmentAnythingEmbeddingsV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpscaleV1ControllerInput} upscaleV1ControllerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerRunUpscaleV1V1(upscaleV1ControllerInput: UpscaleV1ControllerInput, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerRunUpscaleV1V1(upscaleV1ControllerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public operationsControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).operationsControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OperationsControllerListOperationsV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type OperationsControllerListOperationsV1OrderByEnum = typeof OperationsControllerListOperationsV1OrderByEnum[keyof typeof OperationsControllerListOperationsV1OrderByEnum];


/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerCreatePipelineV1: async (createPipelineParamsDto: CreatePipelineParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPipelineParamsDto' is not null or undefined
            assertParamExists('pipelinesControllerCreatePipelineV1', 'createPipelineParamsDto', createPipelineParamsDto)
            const localVarPath = `/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPipelineParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerGetPipelineV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesControllerGetPipelineV1', 'id', id)
            const localVarPath = `/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerListPipelinesV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerUpdatePipelineV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelinesControllerUpdatePipelineV1', 'id', id)
            const localVarPath = `/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerCreatePipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerGetPipelineV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerGetPipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerListPipelinesV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerListPipelinesV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerListPipelinesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelinesControllerUpdatePipelineV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelinesControllerUpdatePipelineV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.pipelinesControllerUpdatePipelineV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePipelineParamsDto} createPipelineParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<PipelineEntity> {
            return localVarFp.pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.pipelinesControllerGetPipelineV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerListPipelinesV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.pipelinesControllerListPipelinesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelinesControllerUpdatePipelineV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.pipelinesControllerUpdatePipelineV1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * 
     * @param {CreatePipelineParamsDto} createPipelineParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerCreatePipelineV1(createPipelineParamsDto: CreatePipelineParamsDto, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerCreatePipelineV1(createPipelineParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerGetPipelineV1(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerGetPipelineV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerListPipelinesV1(options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerListPipelinesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public pipelinesControllerUpdatePipelineV1(id: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).pipelinesControllerUpdatePipelineV1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PosesApi - axios parameter creator
 * @export
 */
export const PosesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerGetPoseV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('posesControllerGetPoseV1', 'id', id)
            const localVarPath = `/v1/poses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerListPosesV1: async (orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/poses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PosesApi - functional programming interface
 * @export
 */
export const PosesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PosesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerGetPoseV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerGetPoseV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posesControllerListPosesV1(orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPosesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posesControllerListPosesV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PosesApi.posesControllerListPosesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PosesApi - factory interface
 * @export
 */
export const PosesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PosesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PoseEntity> {
            return localVarFp.posesControllerGetPoseV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posesControllerListPosesV1(orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPosesDto> {
            return localVarFp.posesControllerListPosesV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PosesApi - object-oriented interface
 * @export
 * @class PosesApi
 * @extends {BaseAPI}
 */
export class PosesApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerGetPoseV1(id: string, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerGetPoseV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PosesControllerListPosesV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PosesApi
     */
    public posesControllerListPosesV1(orderBy?: PosesControllerListPosesV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return PosesApiFp(this.configuration).posesControllerListPosesV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PosesControllerListPosesV1OrderByEnum = {
    Asc: 'createdAt_ASC',
    Desc: 'createdAt_DESC'
} as const;
export type PosesControllerListPosesV1OrderByEnum = typeof PosesControllerListPosesV1OrderByEnum[keyof typeof PosesControllerListPosesV1OrderByEnum];


/**
 * StacksApi - axios parameter creator
 * @export
 */
export const StacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerAddItemsV1: async (id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerAddItemsV1', 'id', id)
            // verify required parameter 'addItemsToStackControllerParamsDto' is not null or undefined
            assertParamExists('stacksControllerAddItemsV1', 'addItemsToStackControllerParamsDto', addItemsToStackControllerParamsDto)
            const localVarPath = `/v1/stacks/{id}/items/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addItemsToStackControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerCreateStackV1: async (createStackParamsDto: CreateStackParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStackParamsDto' is not null or undefined
            assertParamExists('stacksControllerCreateStackV1', 'createStackParamsDto', createStackParamsDto)
            const localVarPath = `/v1/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStackParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerGetStackV1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerGetStackV1', 'id', id)
            const localVarPath = `/v1/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerListStacksV1: async (orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerRemoveItemsV1: async (id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerRemoveItemsV1', 'id', id)
            // verify required parameter 'removeItemsFromCollectionControllerParamsDto' is not null or undefined
            assertParamExists('stacksControllerRemoveItemsV1', 'removeItemsFromCollectionControllerParamsDto', removeItemsFromCollectionControllerParamsDto)
            const localVarPath = `/v1/stacks/{id}/items/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeItemsFromCollectionControllerParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerUpdateMetadataV1: async (id: string, updateMetadataDto: UpdateMetadataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stacksControllerUpdateMetadataV1', 'id', id)
            // verify required parameter 'updateMetadataDto' is not null or undefined
            assertParamExists('stacksControllerUpdateMetadataV1', 'updateMetadataDto', updateMetadataDto)
            const localVarPath = `/v1/stacks/{id}/metadata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StacksApi - functional programming interface
 * @export
 */
export const StacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerAddItemsV1(id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerAddItemsV1(id, addItemsToStackControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerAddItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerCreateStackV1(createStackParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerCreateStackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerGetStackV1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerGetStackV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStacksDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerListStacksV1(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerListStacksV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StackEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerRemoveItemsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stacksControllerUpdateMetadataV1(id, updateMetadataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StacksApi.stacksControllerUpdateMetadataV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StacksApi - factory interface
 * @export
 */
export const StacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StacksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerAddItemsV1(id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerAddItemsV1(id, addItemsToStackControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateStackParamsDto} createStackParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerCreateStackV1(createStackParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerGetStackV1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
         * @param {number} [limit] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListStacksDto> {
            return localVarFp.stacksControllerListStacksV1(orderBy, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StackEntity> {
            return localVarFp.stacksControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetadataDto} updateMetadataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig): AxiosPromise<ResourceEntity> {
            return localVarFp.stacksControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StacksApi - object-oriented interface
 * @export
 * @class StacksApi
 * @extends {BaseAPI}
 */
export class StacksApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {AddItemsToStackControllerParamsDto} addItemsToStackControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerAddItemsV1(id: string, addItemsToStackControllerParamsDto: AddItemsToStackControllerParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerAddItemsV1(id, addItemsToStackControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateStackParamsDto} createStackParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerCreateStackV1(createStackParamsDto: CreateStackParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerCreateStackV1(createStackParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerGetStackV1(id: string, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerGetStackV1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StacksControllerListStacksV1OrderByEnum} [orderBy] 
     * @param {number} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerListStacksV1(orderBy?: StacksControllerListStacksV1OrderByEnum, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerListStacksV1(orderBy, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RemoveItemsFromCollectionControllerParamsDto} removeItemsFromCollectionControllerParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerRemoveItemsV1(id: string, removeItemsFromCollectionControllerParamsDto: RemoveItemsFromCollectionControllerParamsDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerRemoveItemsV1(id, removeItemsFromCollectionControllerParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetadataDto} updateMetadataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stacksControllerUpdateMetadataV1(id: string, updateMetadataDto: UpdateMetadataDto, options?: RawAxiosRequestConfig) {
        return StacksApiFp(this.configuration).stacksControllerUpdateMetadataV1(id, updateMetadataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StacksControllerListStacksV1OrderByEnum = {
    CreatedAtAsc: 'createdAt_ASC',
    CreatedAtDesc: 'createdAt_DESC',
    UpdatedAtAsc: 'updatedAt_ASC',
    UpdatedAtDesc: 'updatedAt_DESC'
} as const;
export type StacksControllerListStacksV1OrderByEnum = typeof StacksControllerListStacksV1OrderByEnum[keyof typeof StacksControllerListStacksV1OrderByEnum];


/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerCreateRecordV1: async (createStorageRecordParamsDto: CreateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerCreateRecordV1', 'createStorageRecordParamsDto', createStorageRecordParamsDto)
            const localVarPath = `/v1/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerDeleteRecordV1: async (deleteStorageParamsDto: DeleteStorageParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteStorageParamsDto' is not null or undefined
            assertParamExists('storageControllerDeleteRecordV1', 'deleteStorageParamsDto', deleteStorageParamsDto)
            const localVarPath = `/v1/storage/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStorageParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerGetRecordsV1: async (getStorageRecordParamsDto: GetStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerGetRecordsV1', 'getStorageRecordParamsDto', getStorageRecordParamsDto)
            const localVarPath = `/v1/storage/values`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerUpdateRecordV1: async (updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStorageRecordParamsDto' is not null or undefined
            assertParamExists('storageControllerUpdateRecordV1', 'updateStorageRecordParamsDto', updateStorageRecordParamsDto)
            const localVarPath = `/v1/storage/write`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStorageRecordParamsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerCreateRecordV1(createStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerCreateRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerDeleteRecordV1(deleteStorageParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerDeleteRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageRecordsResultDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerGetRecordsV1(getStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerGetRecordsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.storageControllerUpdateRecordV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.storageControllerCreateRecordV1(createStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storageControllerDeleteRecordV1(deleteStorageParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<Array<StorageRecordsResultDto>> {
            return localVarFp.storageControllerGetRecordsV1(getStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig): AxiosPromise<StorageEntity> {
            return localVarFp.storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * 
     * @param {CreateStorageRecordParamsDto} createStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerCreateRecordV1(createStorageRecordParamsDto: CreateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerCreateRecordV1(createStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteStorageParamsDto} deleteStorageParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerDeleteRecordV1(deleteStorageParamsDto: DeleteStorageParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerDeleteRecordV1(deleteStorageParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetStorageRecordParamsDto} getStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerGetRecordsV1(getStorageRecordParamsDto: GetStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerGetRecordsV1(getStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateStorageRecordParamsDto} updateStorageRecordParamsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public storageControllerUpdateRecordV1(updateStorageRecordParamsDto: UpdateStorageRecordParamsDto, options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).storageControllerUpdateRecordV1(updateStorageRecordParamsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadFileV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadControllerUploadFileV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadControllerUploadFileV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.uploadControllerUploadFileV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadFileV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadControllerUploadFileV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadFileV1(options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).uploadControllerUploadFileV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebsocketApi - axios parameter creator
 * @export
 */
export const WebsocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerGetSettingsV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/websocket/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerRegisterWebsocketV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/websocket/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsocketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketControllerGetSettingsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsocketApi.websocketControllerGetSettingsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketControllerRegisterWebsocketV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebsocketApi.websocketControllerRegisterWebsocketV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsocketApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.websocketControllerGetSettingsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.websocketControllerRegisterWebsocketV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketControllerGetSettingsV1(options?: RawAxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketControllerGetSettingsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketControllerRegisterWebsocketV1(options?: RawAxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketControllerRegisterWebsocketV1(options).then((request) => request(this.axios, this.basePath));
    }
}



